# JVM

![](https://github.com/Chengganghu/PATHTOBRILLIANT/blob/master/Chenggang/tiantianxuexi/img/jvm.png)  

## 1.对象创建

在为新生对象分配内存时，有两种方式，**指针碰撞**和**空闲列表**，指针碰撞用于规整的内存块，分配内存时只需要移动指针即可，空闲列表需要维护一个可用内存的列表，用与内存块不规整的场景下。

内存分配期间会有线程安全问题，再给A对象分配内存时，B对象也在分配内存，移动指针或者更新空闲列表时会发生线程安全的问题。有两种方式保证此情形下的线程安全：

- CAS
- TLAB（Thread Local Allocation Buffer）：每个线程都会在Java堆中分配到一小块内存，称为**本地线程分配缓冲**， 哪个线程需要分配内存，就在哪个TLAB上分配，只有在TLAB用完并重新分配时才需要同步锁定。

## 2.对象的内存布局

 **对象头,实例数据,对齐填充**,位于Java堆中（Java堆就是用于存放Java实例）

实例数据和类型数据的区别：

实例数据存放于Java堆中，存放对象中各个实例字段的数据。

类型数据存放于方法区中，存放对象的类型，父类，实现的接口，方法等

## 3.OutOfMemoryError

除了程序计数器之外，其余4个内存区域都会发生内存溢出的错误

### 3.1 java堆溢出

只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常

### 3.2 虚拟机栈和本地方法栈溢出

- 线程请求的栈深度大于虚拟机所允许的最大深度，会抛出stack overflow异常
- 虚拟机在扩展栈时无法申请到足够内存，还是会抛出stack overflow异常
- 在不断创建线程的过程中，会导致OutOfMermoryError

### 3.3 方法区和运行时常量池溢出

不断的执行Stirng.intern()，会导致运行常量池溢出，报OOM错误



## 4 垃圾回收

### 4.1 判断对象是否还存活

- 引用计数法 存在互相引用的问题
- 可达性分析算法：已GC Roots对象作为起点，开始向下搜索，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的

GC Root包括： 虚拟机栈中引用的对象（线程中用到的局部变量），方法区中类的静态属性引用的对象，方法区常量引用的对象，本地方法栈中JNI（Native方法）引用的对象

Java中引用分为强引用，软引用，弱引用和虚引用

- 强引用：程序代码中普遍存在的
- 软引用：在发生内存溢出异常之前，将会把这些软引用的对象列进回收范围中进行回收，用**SoftReference**来修饰该类引用
- 弱引用：用来描述非必须的对象，弱引用关联的对象只存活到下一次垃圾回收之前，用**WeakReference**来修饰

要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，接下来判断是否有需要执行finalize()方法，如果对象有必要执行finalize方法，对象会被放在一个F-Queue中，由一个低优先级的Finalizer线程去执行。执行完毕之后，如果对象没有自救，则会被真正回收。



## 4.2 垃圾回收算法

### 4.2.1 标记-清除算法

最简单的清除算法，先标记需要回收的对象，然后清除，有两个缺陷：一个是效率问题，一个是会产生内存碎片

### 4.2.2 复制算法

复制算法是为了解决效率问题。复制算法将内存容量分为大小相等的两块，每次只使用一块，每次只使用一块，当一块内存用完了就将还存活的对象复制到另外一块上面。所以在内存分配时也就不需要考虑内存碎片等复杂情况，只用移动堆顶指针，按顺序分配内存即可。

目前的虚拟机都是将内存分为较大的Eden空间和两片较小的Survivor空间，每次只用Eden和一片Survivor空间，内存用完时，将还存活的对象复制到未使用的Survivor上，并将Eden和Survivor清空。一般Eden:Survivor = 8:1

### 4.2.3 标记-整理算法

当对象存活率较高时，如果是用复制算法，就需要进行较多的复制操作。该算法的过程是先标记，再将存活的对象向一端移动，然后清理掉边界外的内存

### 4.2.4 分代手机算法

一般把Java堆分成**新生代**和**老年代**，新生代每次都有大量对象死亡，所以用复制算法，老年代对象存活率高，所以使用标记清除或者标记整理算法