# JVM

![](https://github.com/Chengganghu/PATHTOBRILLIANT/blob/master/Chenggang/tiantianxuexi/img/jvm.png)  

## 1.对象创建

在为新生对象分配内存时，有两种方式，**指针碰撞**和**空闲列表**，指针碰撞用于规整的内存块，分配内存时只需要移动指针即可，空闲列表需要维护一个可用内存的列表，用与内存块不规整的场景下。

内存分配期间会有线程安全问题，再给A对象分配内存时，B对象也在分配内存，移动指针或者更新空闲列表时会发生线程安全的问题。有两种方式保证此情形下的线程安全：

- CAS
- TLAB（Thread Local Allocation Buffer）：每个线程都会在Java堆中分配到一小块内存，称为**本地线程分配缓冲**， 哪个线程需要分配内存，就在哪个TLAB上分配，只有在TLAB用完并重新分配时才需要同步锁定。

## 2.对象的内存布局

 **对象头,实例数据,对齐填充**,位于Java堆中（Java堆就是用于存放Java实例）

实例数据和类型数据的区别：

实例数据存放于Java堆中，存放对象中各个实例字段的数据。

类型数据存放于方法区中，存放对象的类型，父类，实现的接口，方法等

## 3.OutOfMemoryError

除了程序计数器之外，其余4个内存区域都会发生内存溢出的错误

### 3.1 java堆溢出

只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常

### 3.2 虚拟机栈和本地方法栈溢出

- 线程请求的栈深度大于虚拟机所允许的最大深度，会抛出stack overflow异常
- 虚拟机在扩展栈时无法申请到足够内存，还是会抛出stack overflow异常
- 在不断创建线程的过程中，会导致OutOfMermoryError

### 3.3 方法区和运行时常量池溢出

不断的执行Stirng.intern()，会导致运行常量池溢出，报OOM错误



## 4 垃圾回收

### 4.1 判断对象是否还存活

- 引用计数法 存在互相引用的问题
- 可达性分析算法：已GC Roots对象作为起点，开始向下搜索，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的

GC Root包括： 虚拟机栈中引用的对象（线程中用到的局部变量），方法区中类的静态属性引用的对象，方法区常量引用的对象，本地方法栈中JNI（Native方法）引用的对象

Java中引用分为强引用，软引用，弱引用和虚引用

- 强引用：程序代码中普遍存在的
- 软引用：在发生内存溢出异常之前，将会把这些软引用的对象列进回收范围中进行回收，用**SoftReference**来修饰该类引用
- 弱引用：用来描述非必须的对象，弱引用关联的对象只存活到下一次垃圾回收之前，用**WeakReference**来修饰

要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析之后发现没有与GC Roots相连接的引用链，接下来判断是否有需要执行finalize()方法，如果对象有必要执行finalize方法，对象会被放在一个F-Queue中，由一个低优先级的Finalizer线程去执行。执行完毕之后，如果对象没有自救，则会被真正回收。



## 4.2 垃圾回收算法

### 4.2.1 标记-清除算法

最简单的清除算法，先标记需要回收的对象，然后清除，有两个缺陷：一个是效率问题，一个是会产生内存碎片

### 4.2.2 复制算法

复制算法是为了解决效率问题。复制算法将内存容量分为大小相等的两块，每次只使用一块，每次只使用一块，当一块内存用完了就将还存活的对象复制到另外一块上面。所以在内存分配时也就不需要考虑内存碎片等复杂情况，只用移动堆顶指针，按顺序分配内存即可。

目前的虚拟机都是将内存分为较大的Eden空间和两片较小的Survivor空间，每次只用Eden和一片Survivor空间，内存用完时，将还存活的对象复制到未使用的Survivor上，并将Eden和Survivor清空。一般Eden:Survivor = 8:1

### 4.2.3 标记-整理算法

当对象存活率较高时，如果是用复制算法，就需要进行较多的复制操作。该算法的过程是先标记，再将存活的对象向一端移动，然后清理掉边界外的内存

### 4.2.4 分代收集算法

一般把Java堆分成**新生代**和**老年代**，新生代每次都有大量对象死亡，所以用复制算法，老年代对象存活率高，所以使用标记清除或者标记整理算法



**Stop the world:** 在由GC Roots节点找到引用链的过程中，必须确保在一致性的快照中进行。一致性是指整个分析期间系统看起来就像被冻在某个时间点上，不可以出现分析过程中对象引用关系还在不断的变化的情况，这点是导致GC时必须停顿所有Java线程的一个重要原因



## 4.3 垃圾收集器

![](https://github.com/Chengganghu/PATHTOBRILLIANT/blob/master/Chenggang/tiantianxuexi/img/gc.png)

### 4.3.1 Serial收集器

Serial收集器是最基本、发展历史最悠久的收集器，是个单线程收集器，在GC线程工作时，会暂定其他所有的工作线程（Stop the world）。只用于新生代的垃圾收集，使用复制算法

### 4.3.2 ParNew收集器

Serial收集器的多线程版，单CPU当中效率不一定比Serial高，但是多CPU会提升效率

### 4.3.3 Parallel Sacvenge收集器

吞度量优先收集器，和ParNew一样是新生代，复制算法，并行的垃圾收集器

吞吐量  = 运行代码时间/（运行代码时间 + 垃圾收集时间）

垃圾收集时间 = 每次GC的停顿时间 * 收集的次数

停顿时间短适合需要与用户交互的程序，可以提供良好的响应速度从而提升用户体验，高吞吐量可以高效的利用CPU，尽快的完成程序的运算任务，适合后台运算而不需要太多交互的任务。

Parallel Sacvenge有两个参数精确控制吞吐量：**控制最大垃圾收集停顿时间：-XX:MaxGCPauseMillis**和**直接设置吞吐量大小：-XX:GCTimeRatio**。

GC停顿时间的缩短是以牺牲吞吐量和新生代空间来换取的，新生代越小，垃圾收集停顿时间越短，但是垃圾收集的次数变多，间接导致吞吐量下降。

Parallel Sacvenge收集器还有一个参数可以控制：**-XX:UseAdaptiveSizePolicy**, 这是一个开关参数，就不需要手动指定新生代大小(**-Xmn**), Eden与Survivor区的比例(**-XX:SurvivorRatio**), 晋升老年代对象大小(**-XX:PretenureSizeThreshold**)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间和吞吐量。

### 4.3.4 Serial Old收集器

Serial收集器的老年代版本，同样是单线程收集器，和Serial不同的是，使用标记整理算法

### 4.3.5 Parallel Old收集器

是Parallel Sacvenge收集器的老年代版本，使用多线程和标记整理算法，与Parallel Sacvenge配合使用

### 4.3.6 CMS收集器 Concurrent Mark Sweep

是一种获取最短回收停顿时间为目标的收集器，应用于重视服务的响应速度，希望系统停顿时间最短的场景。

CMS收集器基于“标记-清除”算法，作用于老年代，过程分为4个步骤：

- 初始标记 need stop the world
- 并发标记
- 重新标记 need stop the world
- 并发清楚

初始标记只是标记GC Roots能直接关联到的对象，速度很快，并发标记就是GC Roots Tracing的过程，此时GC线程和用户线程并发同时运行，不会导致stop the world，重新标记就是修正并发标记期间因为程序继续运作而导致标记记录变动的那一部分，这个阶段也会有停顿，但是远比并发标记的时间短。

CMS收集器有三个缺陷：

- 对CPU资源敏感，虽然不会导致用户线程停顿，但是会占用一部分线程资源
- 无法处理浮动垃圾，浮动垃圾是指在并发清理阶段，伴随着程序的运行，还会有新的垃圾产生，这部分垃圾只能等到下一次GC时才能清理掉，所以不能只在老年代几乎被填满的时候再进行收集，需要预留一部分空间提供并发收集时的程序使用，JDK1.5的默认设置中，CMS会在老年代使用了68%的时候激活垃圾回收。
- 由于是使用标记-清除算法，所以会产生大量内存碎片



### 4.3.7 G1（Garbage First）收集器

有时间再仔细研究一下



