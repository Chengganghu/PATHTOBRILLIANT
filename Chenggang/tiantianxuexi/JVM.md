# JVM

![](https://github.com/Chengganghu/2019chunzhao/blob/master/img/jvm.png)  

## 1.对象创建

在为新生对象分配内存时，有两种方式，**指针碰撞**和**空闲列表**，指针碰撞用于规整的内存块，分配内存时只需要移动指针即可，空闲列表需要维护一个可用内存的列表，用与内存块不规整的场景下。

内存分配期间会有线程安全问题，再给A对象分配内存时，B对象也在分配内存，移动指针或者更新空闲列表时会发生线程安全的问题。有两种方式保证此情形下的线程安全：

- CAS
- TLAB（Thread Local Allocation Buffer）：每个线程都会在Java堆中分配到一小块内存，称为**本地线程分配缓冲**， 哪个线程需要分配内存，就在哪个TLAB上分配，只有在TLAB用完并重新分配时才需要同步锁定。

## 2.对象的内存布局

 **对象头,实例数据,对齐填充**,位于Java堆中（Java堆就是用于存放Java实例）

实例数据和类型数据的区别：

实例数据存放于Java堆中，存放对象中各个实例字段的数据。

类型数据存放于方法区中，存放对象的类型，父类，实现的接口，方法等

## 3.OutOfMemoryError

除了程序计数器之外，其余4个内存区域都会发生内存溢出的错误

### 3.1 java堆溢出

只要不断的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常

### 3.2 虚拟机栈和本地方法栈溢出

- 线程请求的栈深度大于虚拟机所允许的最大深度，会抛出stack overflow异常
- 虚拟机在扩展栈时无法申请到足够内存，还是会抛出stack overflow异常
- 在不断创建线程的过程中，会导致OutOfMermoryError

### 3.3 方法区和运行时常量池溢出

不断的执行Stirng.intern()，会导致运行常量池溢出，报OOM错误