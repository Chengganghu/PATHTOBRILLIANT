# redis 对象（数据结构）

对象的**类型**与**编码**， type and encoding

- 字符串对象

编码方式有三种：int raw embstr

如果能用long型表示，字符串对象会自动转换为int型（redis中除了long，其余全部是指针类型，类似于Java中引用数据类型）

raw就是SDS，在大于39个字节的时候会使用SDS

embstr用于存储短字符串值，小于39字节，redisObject和SDSObject使用连续的内存空间

- 列表对象

编码方式：压缩列表或者是链表

- 哈希对象

编码方式：压缩列表或者是哈希表

- 集合对象

编码方式：整数集合或者是哈希表

集合对象的哈希表实现方式中，只用字典的key存值，而字典的value置为空

- 有序集合对象

编码方式：压缩列表或者是跳表

如果使用跳表作为有序集合的编码方式，那么还会同时使用字典存储集合元素和元素得分



redis对象使用**引用计数**作为内存回收的方式

内存使用过高时，redis会自动清除对象空转时长较长的对象



# 数据库

## 过期策略

给某个键设置过期时长 **EXPIRE PEXPIRE**，在多长时间之后过期

给某个键设置过期时间点 **EXPIREAT PEXPIREAT**， 在某个时间点过期

P指毫秒

**PERSIST** 取消某个键的过期时间

过期键删除策略：

- 定时删除

通过使用定时器，保证过期的键会被及时删除，但是会损耗大量CPU，此方法不现实

- 惰性删除

只在取出键的时候进行过期判断，对cpu友好，对内存不友好

- 定期删除

每隔一段时间执行一次删除过期键的操作，并且限制删除操作的时长和频率减少删除操作对CPU的影响

redis当中是配合使用惰性删除和定期删除策略

## AOF RDB

生成RDB文件时，忽略过期键，载入RDB文件时，主服务器忽略过期键，从服务器全部载入

生成AOF文件时，会显式的追加一条DEL语句用与删除过期键，载入时会忽略过期键

- RDB

SAVE 和 BGSAVE（BackGroud SAVE）

save会阻塞redis服务器进程，BGSAVE不会阻塞redis服务器进程，bgsave会folk出一个子进程

载入RDB文件只在redis服务器重启时

RDB**自动间隔性保存**，可以设置**save**选项：

save 900 1 ：900秒内对数据库进行了至少一次修改

save 300 10: 300秒内对数据了进行了至少十次修改

save 60 10000： 60秒内对数据库进行了至少10000次修改

**dirty计数器**：记录上一次执行save命令或者BGSAVE命令后，服务器对数据库状态进行了多少次修改

**lastSave**：unix时间戳，记录服务器上一次成功执行save或者bgsave命令的时间

**主从同步需要用到RDB文件**

- AOF

aof_buf: aof缓冲区，追加的命令会先保存在aof_buf缓存区

redis服务器进程类似于一个事件循环

```
def eventLoop():
	while True:  //死循环
	processFileEvents(); // 处理文件事件，接收命令以及发送命令回复，处理命令请求时可能会有新内容追加到aof_buf
	processTimeEvents(); // 处理时间时间
	flushAppendOnlyFile(); // 将aof_buf缓存区的值写入到aof文件中
```

appendfsync选项的值来决定何时将aof_buf缓存里面的数据写入到aof文件中

| appendfsync的值 | flushAppendOnlyFile函数的行为                                |
| :-------------- | ------------------------------------------------------------ |
| always          | 将aof_buf缓冲区的所有内容写入并同步到aof文件中               |
| everysec        | 将aof_buf缓冲区的所有内容写入到aof文件，如果上次同步aof文件的时间超过一秒钟，那么再次对aof文件进行同步 |
| no              | 将aof_buf缓冲区的文件的所有内容写入到aof文件，但不对aof文件进行同步，何时同步由操作系统决定 |

默认配置是everysec

执行命令 －> 在处理**文件事件**时添加到aof_buf中 －> 将缓冲区内容写到aof文件 －> 同步aof文件

## 事件

- 文件事件

- 时间事件

serverCron函数    每100毫秒执行一次

－ 更新服务器各类统计信息，比如时间，内存占用，数据库占用等

－ 清理数据库的过期健值对

－  关闭和清理失效的客户端

－ 尝试进行aof和rdb持久化操作

－ 主服务器对从服务器进行定期同步

－ 集群模式下，定期同步和连接测试

 

## 复制

主从服务器数据库保存相同的数据

### 旧版复制功能的实现

- 同步 sync 将从服务器的数据库状态更新至主服务器的数据看状态
- 命令传播 command propagate 主服务器状态被修改，导致主从不一致，让主从服务器重回一致的状态

当执行完slaveof命令后，主服务器会生成RDB文件，并将RDB文件发送给从服务器执行（RDB缓存区用来接受BGSAVE时执行的命令）

### 新版复制功能的实现

PSYNC （partial sync）

PSYNC具有full sync完整重同步和partial sync部分重同步

完整重同步用于第一次复制主服务器时，而部分重同步用于断线重连后复制主服务器

部分重同步由以下三个部分构成：

- 主服务器的复制偏移量和从服务器的复制偏移量
- 主服务器的复制积压缓冲区
- 服务器的运行ID

主从服务器都会维护一个**复制偏移量**，如果主从一致，复制偏移量相同，如果主从不一致，复制偏移量不同，此时从服务器向主服务器发送PSYNC请求

复制积压缓冲区是由主服务器维护的一个固定长度先进先出的队列，默认大小为1MB，里面存有主服务器向从服务器传播的写命令

### 心跳检测 

从服务器向主服务器发送REPLCONF ACK，会带上从服务器的复制偏移量

- 检测主从网络状态连接：主从服务器通过发送和接收REPLCONF ACK命令来检查主从之间网络状态是否正常，每秒发送一次
- 辅助实现min-slaves配置选项
- 检测命令丢失，如果主从复置偏移量不同，则有命令丢失



## 集群

### 1.槽指派

Redis集群通过分片的方式保存数据库中的键值对，集群数据库被分为16384个槽slot，在clusterNode结构中，用二进制位数组（bitmap）来记录槽的使用情况，在clusterState结构中，用指针数组指向每一个槽对应的节点

可以使用**CLUSRTER ADDSLOTS**将槽指定给某节点

计算给定键属于哪个槽：  CRC16(key) & 16383



### 2.重新分片

### 3.复制与故障转移

主节点是用于处理槽相关的信息，从节点只复制主节点信息，当主节点发生故障时，将新选举出来的主节点用于负责处理之前主节点的槽相关信息

### 4.集群节点的故障检测

集群中每个节点都会定期向集群中其他节点发送PING信息，以此来判断对方是否下线，如果其他节点没有返回PONG响应，则会被标记为疑似下线，并向其他主节点发送该节点的下线报告，如果集群中超过半数的主节点（负责槽分配的节点）将一个节点标记为疑似下线，则该节点在集群中正式下线，其从节点中会有一个被选为新的主节点，负责槽分配。



### 5.选举新的节点

当一个主节点下线时，其从节点会向集群中每个负责处理槽的主节点发送FAILOVER请求，在同一个配置纪元中，最先收到请求的节点会获得一票，当从节点获得半数以上投票时，会被选举为新的主节点

##  面试题相关

#### 1.redis内存淘汰机制（如何保证redis存储的都是热点数据）

- **volatile-lru：** 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
- **volatile-ttl：**从已设置过期时间的数据集中挑选将要过期的数据淘汰
- **volatile-random：**从已设置过期时间的数据集中任意淘汰数据
- **allkeys-random：**从数据集中任意淘汰数据
- **allkeys-lru：**当内存不足以写入新数据时，在键空间中移除最近最少使用的key（最常用）

